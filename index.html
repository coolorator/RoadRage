<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>RoadRage</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 3. Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            background-color: #000000;
            margin: 0;
            overflow: hidden;
            overscroll-behavior: none;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: 'Arial Black', sans-serif; /* Dickerer Font für Straße */
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #111827; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #374151; border-radius: 4px; }
        
        @keyframes marquee {
          0% { transform: translateX(100vw); } 
          100% { transform: translateX(-100%); } 
        }

        .will-change-transform { will-change: transform; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- INLINE ICONS (Kein Server nötig) ---
        const IconBase = ({ children, size = 24, className = "", ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>
                {children}
            </svg>
        );

        const Mic = (props) => <IconBase {...props}><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></IconBase>;
        const MicOff = (props) => <IconBase {...props}><line x1="2" x2="22" y1="2" y2="22"/><path d="M18.89 13.23A7.12 7.12 0 0 0 19 12v-2"/><path d="M5 10v2a7 7 0 0 0 12 5"/><path d="M15 9.34V5a3 3 0 0 0-5.68-1.33"/><path d="M9 9v3a3 3 0 0 0 5.12 2.63"/><line x1="12" x2="12" y1="19" y2="22"/></IconBase>;
        const Play = (props) => <IconBase {...props}><polygon points="6 3 20 12 6 21 6 3"/></IconBase>;
        const X = (props) => <IconBase {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
        const Zap = (props) => <IconBase {...props}><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></IconBase>;
        const RotateCcw = (props) => <IconBase {...props}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>;
        const PenTool = (props) => <IconBase {...props}><path d="m12 19 7-7 3 3-7 7-3-3z"/><path d="m18 13-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="m2 2 7.586 7.586"/><circle cx="11" cy="11" r="2"/></IconBase>;
        const Check = (props) => <IconBase {...props}><path d="M20 6 9 17l-5-5"/></IconBase>;
        const Trash2 = (props) => <IconBase {...props}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></IconBase>;
        const Type = (props) => <IconBase {...props}><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" x2="15" y1="20" y2="20"/><line x1="12" x2="12" y1="4" y2="20"/></IconBase>;
        const Sparkles = (props) => <IconBase {...props}><path d="m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z"/></IconBase>;
        const Loader2 = (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56"/></IconBase>;
        const RotateCw = (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/></IconBase>;
        const Settings = (props) => <IconBase {...props}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></IconBase>;
        const AlertCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></IconBase>;
        const Maximize2 = (props) => <IconBase {...props}><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/></IconBase>;
        // NEU: Spiegel-Icon
        const FlipHorizontal = (props) => <IconBase {...props}><path d="M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3"/><path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/><path d="M12 20v2"/><path d="M12 14v2"/><path d="M12 8v2"/><path d="M12 2v2"/></IconBase>;

        // --- KONFIGURATION ---
        const THEMES = [
          { id: 'warning', bg: '#000000', text: '#FFD700', name: 'Baustelle', label: 'Gelb/Schwarz' },
          { id: 'emergency', bg: '#cc0000', text: '#FFFFFF', name: 'Notfall', label: 'Weiß/Rot' },
          { id: 'police', bg: '#0000FF', text: '#FFFFFF', name: 'Polizei', label: 'Weiß/Blau' },
          { id: 'matrix', bg: '#000000', text: '#00FF00', name: 'Matrix', label: 'Grün/Schwarz' },
          { id: 'high-vis', bg: '#FFFFFF', text: '#000000', name: 'Klassisch', label: 'Schwarz/Weiß' },
        ];

        const DEFAULT_QUICK_TEXTS = [
          "DANKE", "STOP", "LICHT AN", "TÜR ZU", 
          "FOLGEN", "HILFE", "POLIZEI", "ABSTAND"
        ];

        const App = () => {
          // STATE
          const [text, setText] = useState(() => localStorage.getItem('marquee_text') || '');
          const [presets, setPresets] = useState(() => {
            try {
                const saved = localStorage.getItem('marquee_presets');
                return saved ? JSON.parse(saved) : DEFAULT_QUICK_TEXTS;
            } catch(e) { return DEFAULT_QUICK_TEXTS; }
          });

          const [isEditingPresets, setIsEditingPresets] = useState(false);
          const [editingIndex, setEditingIndex] = useState(null);
          const [tempEditText, setTempEditText] = useState('');
          
          // AI
          const [isAiLoading, setIsAiLoading] = useState(false);
          const [showAiModal, setShowAiModal] = useState(false);
          const [aiTopic, setAiTopic] = useState('');
          const [aiError, setAiError] = useState('');
          const [userApiKey, setUserApiKey] = useState(() => localStorage.getItem('marquee_api_key') || '');
          const [showApiKeyInput, setShowApiKeyInput] = useState(false);

          // App Logic
          const [isRecording, setIsRecording] = useState(false);
          const [isPlaying, setIsPlaying] = useState(false);
          const [selectedTheme, setSelectedTheme] = useState(THEMES[0]);
          const [speedMultiplier, setSpeedMultiplier] = useState(3.0); 
          const [animationDuration, setAnimationDuration] = useState(10);
          const [isRotated, setIsRotated] = useState(false);
          
          // NEU: Spiegel-Status
          const [isMirrored, setIsMirrored] = useState(false);

          const recognitionRef = useRef(null);
          const wakeLockRef = useRef(null);
          const editInputRef = useRef(null);
          const aiInputRef = useRef(null);
          const marqueeContainerRef = useRef(null);

          // EFFECTS
          useEffect(() => { localStorage.setItem('marquee_text', text); }, [text]);
          useEffect(() => { localStorage.setItem('marquee_presets', JSON.stringify(presets)); }, [presets]);
          useEffect(() => { localStorage.setItem('marquee_api_key', userApiKey); }, [userApiKey]);

          useEffect(() => {
            if (editingIndex !== null && editInputRef.current) editInputRef.current.focus();
          }, [editingIndex]);

          useEffect(() => {
            if (showAiModal && aiInputRef.current) aiInputRef.current.focus();
          }, [showAiModal]);

          useEffect(() => {
            if (isPlaying) calculateDuration();
          }, [speedMultiplier, text, isRotated, isPlaying]);

          // Speech Init
          useEffect(() => {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
              const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
              recognitionRef.current = new SpeechRecognition();
              recognitionRef.current.continuous = false;
              recognitionRef.current.interimResults = true;
              recognitionRef.current.lang = 'de-DE';

              recognitionRef.current.onresult = (event) => {
                let finalTranscript = '';
                for (let i = event.resultIndex; i < event.results.length; ++i) {
                  if (event.results[i].isFinal) finalTranscript += event.results[i][0].transcript;
                  else setText(event.results[i][0].transcript);
                }
                if (finalTranscript) setText(finalTranscript);
              };
              recognitionRef.current.onend = () => setIsRecording(false);
              recognitionRef.current.onerror = (e) => setIsRecording(false);
            }
          }, []);

          // AI Logic
          const callGemini = async (prompt, systemInstruction = "") => {
            setAiError('');
            if (!userApiKey) { setAiError("KEY FEHLT"); return null; }
            setIsAiLoading(true);
            try {
              const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userApiKey}`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: systemInstruction }] }
                  })
                }
              );
              if (!response.ok) throw new Error("Key ungültig?");
              const data = await response.json();
              setIsAiLoading(false);
              const resultText = data.candidates?.[0]?.content?.parts?.[0]?.text;
              if (!resultText) throw new Error("Keine Antwort.");
              return resultText;
            } catch (error) { 
              setIsAiLoading(false); 
              setAiError(error.message); 
              return null; 
            }
          };

          const optimizeTextWithAi = async () => {
            if (!text.trim()) return;
            const result = await callGemini(`Kürze für Laufschrift (Max 8 Wörter): "${text}"`, "Nur Text.");
            if (result) setText(result.trim());
          };

          const generatePresetsWithAi = async () => {
            if (!aiTopic.trim()) return;
            const result = await callGemini(`8 LED-Texte (Kurz, max 6 Wörter) für Thema: "${aiTopic}". JSON Array.`, "JSON only.");
            if (result) {
              try {
                const cleaned = result.replace(/```json/g, '').replace(/```/g, '').trim();
                const newPresets = JSON.parse(cleaned);
                if (Array.isArray(newPresets)) {
                  setPresets(newPresets.slice(0, 8));
                  setShowAiModal(false);
                  setAiTopic('');
                  setIsEditingPresets(false);
                }
              } catch (e) { setAiError("Datenfehler."); }
            }
          };

          // Helper Logic
          const requestWakeLock = async () => {
            if ('wakeLock' in navigator) {
              try { wakeLockRef.current = await navigator.wakeLock.request('screen'); } catch (err) {}
            }
          };

          const releaseWakeLock = async () => {
            if (wakeLockRef.current) {
                try { await wakeLockRef.current.release(); wakeLockRef.current = null; } catch(e) {}
            }
          };

          const toggleRecording = () => {
            if (isRecording) {
              recognitionRef.current.stop();
            } else {
              setText('');
              recognitionRef.current.start();
              setIsRecording(true);
            }
          };

          const toggleCaps = () => {
            if (text === text.toUpperCase()) setText(text.toLowerCase().replace(/(^|\s)\S/g, l => l.toUpperCase()));
            else setText(text.toUpperCase());
          };

          const calculateDuration = () => {
              const screenWidth = window.innerWidth;
              const approxCharWidth = window.innerHeight * 0.6; 
              const textWidth = text.length * approxCharWidth;
              const totalDistance = screenWidth + textWidth;
              const baseSpeed = 400; 
              const currentSpeed = baseSpeed * speedMultiplier;
              const duration = totalDistance / currentSpeed;
              setAnimationDuration(Math.max(duration, 0.5));
          };

          const forceFullscreen = () => {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen({ navigationUI: "hide" }).catch(e => console.log(e));
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            }
          };

          const startMarquee = () => {
            if (!text.trim()) return;
            forceFullscreen();
            requestWakeLock();
            setIsPlaying(true);
          };

          const stopMarquee = () => {
            setIsPlaying(false);
            releaseWakeLock();
            setIsRotated(false);
            setIsMirrored(false); // Reset Mirror
            
            if (document.exitFullscreen && document.fullscreenElement) {
              document.exitFullscreen().catch(err => console.log(err));
            } else if (document.webkitExitFullscreen) {
              document.webkitExitFullscreen();
            }
          };

          // --- RENDER ---
          if (!isPlaying) {
            return (
              <div className="min-h-screen bg-gray-900 text-white flex font-sans overflow-hidden relative">
                
                {/* MODAL: PRESET EDIT */}
                {editingIndex !== null && (
                  <div className="absolute inset-0 z-[60] bg-black/80 backdrop-blur-sm flex items-center justify-center p-6">
                    <div className="bg-gray-800 border border-gray-600 w-full max-w-sm rounded-2xl p-6 shadow-2xl">
                      <h3 className="text-lg font-bold mb-4 flex items-center gap-2 text-yellow-500">
                         Bearbeiten
                      </h3>
                      <textarea
                        ref={editInputRef}
                        value={tempEditText}
                        onChange={(e) => setTempEditText(e.target.value)}
                        className="w-full bg-gray-900 border border-gray-700 rounded-lg p-4 text-xl text-white mb-6 focus:border-yellow-500 focus:outline-none h-32 resize-none"
                      />
                      <div className="flex gap-3">
                        <button onClick={() => setEditingIndex(null)} className="flex-1 py-3 rounded-xl bg-gray-700 font-bold">Abbrechen</button>
                        <button onClick={() => {
                           const newPresets = [...presets];
                           newPresets[editingIndex] = tempEditText;
                           setPresets(newPresets);
                           setEditingIndex(null);
                        }} className="flex-1 py-3 rounded-xl bg-yellow-500 text-black font-bold">Speichern</button>
                      </div>
                    </div>
                  </div>
                )}

                {/* MODAL: AI */}
                {showAiModal && (
                  <div className="absolute inset-0 z-[60] bg-black/90 backdrop-blur-sm flex items-center justify-center p-6">
                    <div className="bg-gray-800 border border-purple-500/50 w-full max-w-sm rounded-2xl p-6 shadow-2xl relative">
                      <button onClick={() => setShowApiKeyInput(!showApiKeyInput)} className="absolute top-4 right-4 text-gray-500 hover:text-white bg-gray-900 p-2 rounded-full">
                         <Settings size={18} />
                      </button>
                      
                      <h3 className="text-lg font-bold mb-2 flex items-center gap-2 text-purple-400">
                        <Sparkles size={20} /> KI Thema
                      </h3>
                      
                      {showApiKeyInput ? (
                        <div className="mb-4 bg-gray-900 p-3 rounded-lg border border-gray-700 animate-in fade-in">
                          <label className="text-xs text-gray-400 mb-1 block">Dein Google Gemini API Key</label>
                          <input type="password" value={userApiKey} onChange={(e) => setUserApiKey(e.target.value)} placeholder="Key hier einfügen..." className="w-full bg-black border border-gray-600 rounded px-2 py-2 text-sm font-mono text-white" />
                          <p className="text-[10px] text-gray-500 mt-2">Kostenlos erstellen unter aistudio.google.com</p>
                        </div>
                      ) : (
                        <input ref={aiInputRef} type="text" value={aiTopic} onChange={(e) => setAiTopic(e.target.value)} placeholder="z.B. Stadion, Panne..." className="w-full bg-gray-900 border border-gray-700 rounded-lg p-4 text-lg text-white mb-4 focus:border-purple-500 focus:outline-none" onKeyDown={(e) => e.key === 'Enter' && generatePresetsWithAi()} />
                      )}
                      
                      {aiError && (
                        <div className="bg-red-900/30 border border-red-500/30 p-3 rounded-lg mb-4 text-red-200 text-xs flex items-start gap-2">
                           API Fehler: {aiError}
                        </div>
                      )}
                      
                      <div className="flex gap-3">
                        <button onClick={() => setShowAiModal(false)} className="flex-1 py-3 rounded-xl bg-gray-700 font-bold">Zurück</button>
                        {!showApiKeyInput && <button onClick={generatePresetsWithAi} disabled={!aiTopic.trim() || isAiLoading} className="flex-1 py-3 rounded-xl bg-purple-600 hover:bg-purple-500 text-white font-bold flex items-center justify-center gap-2 disabled:opacity-50">{isAiLoading ? 'Lädt...' : 'Start'}</button>}
                      </div>
                    </div>
                  </div>
                )}

                {/* CONTROLS */}
                <div className="flex-grow h-screen overflow-y-auto p-4 pr-16 custom-scrollbar pb-24">
                  <div className="flex justify-between items-center mb-4">
                    <h1 className="text-xl font-black itali
